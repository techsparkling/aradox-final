<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <script src="//cdnjs.cloudflare.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
    <script src="//rawgit.com/mrdoob/stats.js/master/build/stats.min.js"></script>
    <link rel="icon" href="%PUBLIC_URL%/favicon.ico" />

<link href="https://fonts.googleapis.com/css2?family=Open+Sans&display=swap" rel="stylesheet">

    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="theme-color" content="#000000" />
    <meta
      name="description"
      content="Web site created using create-react-app"
    />
    
    <link rel="apple-touch-icon" href="%PUBLIC_URL%/logo192.png" />
    <!--
      manifest.json provides metadata used when your web app is installed on a
      user's mobile device or desktop. See https://developers.google.com/web/fundamentals/web-app-manifest/
    -->
    <link rel="manifest" href="%PUBLIC_URL%/manifest.json" />
    <!--
      Notice the use of %PUBLIC_URL% in the tags above.
      It will be replaced with the URL of the `public` folder during the build.
      Only files inside the `public` folder can be referenced from the HTML.

      Unlike "/favicon.ico" or "favicon.ico", "%PUBLIC_URL%/favicon.ico" will
      work correctly both with client-side routing and a non-root public URL.
      Learn how to configure a non-root public URL by running `npm run build`.
    -->
    <title>React App</title>
  </head>
  <body>
   
    <noscript>You need to enable JavaScript to run this app.</noscript>
  
    <div class="curzr" hidden>
      <div class="curzr-dot"></div>
    </div>
  

    <div id="root"></div>

   


    <!--
      This HTML file is a template.
      If you open it directly in the browser, you will see an empty page.

      You can add webfonts, meta tags, or analytics to this file.
      The build step will place the bundled scripts into the <body> tag.

      To begin the development, run `npm start` or `yarn start`.
      To create a production bundle, use `npm run build` or `yarn build`.
    -->
    <script>
    class RingDot {
        constructor() {
          this.root = document.body;
          this.cursor = document.querySelector(".curzr");
          this.dot = document.querySelector(".curzr-dot");
    
          this.pointerX = 0;
          this.pointerY = 0;
          this.cursorSize = 25;
    
          this.cursorStyle = {
            boxSizing: "border-box",
            position: "fixed",
            display: "flex",
            top: `${this.cursorSize / -2}px`,
            left: `${this.cursorSize / -2}px`,
            zIndex: "2147483647",
            justifyContent: "center",
            alignItems: "center",
            width: `${this.cursorSize}px`,
            height: `${this.cursorSize}px`,
            backgroundColor: "#fff0",
            boxShadow: "0 0 0 1.25px #FF9100, 0 0 0 2.25px #FF9100",
            borderRadius: "50%",
            transition: "200ms, transform 0ms",
            userSelect: "none",
            pointerEvents: "none",
          };
    
          this.dotStyle = {
            boxSizing: "border-box",
            position: "fixed",
            zIndex: "2147483647",
            width: "4px",
            height: "4px",
            backgroundColor: "white",
            boxShadow: "0 0 0 px #FF9100",
            borderRadius: "50%",
            userSelect: "none",
            pointerEvents: "none",
          };
    
          this.init(this.cursor, this.cursorStyle);
          this.init(this.dot, this.dotStyle);
        }
    
        init(el, style) {
          Object.assign(el.style, style);
          this.cursor.removeAttribute("hidden");
    
          document.body.style.cursor = "none";
          document.body
            .querySelectorAll("button, label, input, textarea, select, a")
            .forEach((el) => {
              el.style.cursor = "inherit";
            });
        }
    
        move(event) {
          if (
            event.target.localName === "button" ||
            event.target.localName === "a" ||
            event.target.localName === "img" ||
            event.target.localName === "svg" ||
            event.target.onclick !== null ||
            event.target.className.includes("swiper-pagination-bullet") ||
            event.target.className.includes("curzr-hover")
          ) {
            this.hover(40);
          } else {
            this.hoverout();
          }
    
          this.pointerX = event.pageX + this.root.getBoundingClientRect().x;
          this.pointerY = event.pageY + this.root.getBoundingClientRect().y;
    
          this.cursor.style.transform = `translate3d(${this.pointerX}px, ${this.pointerY}px, 0)`;
        }
    
        hover(radius) {
          this.cursor.style.width = this.cursor.style.height = `${radius}px`;
          this.cursor.style.top = this.cursor.style.left = `${radius / -2}px`;
          this.cursor.style.boxShadow = "0 0 0 1.25px white, 0 0 0 2.25px white";
          this.dot.style.backgroundColor = " #FF9100";
        }
    
        hoverout() {
          this.cursor.style.width =
            this.cursor.style.height = `${this.cursorSize}px`;
          this.cursor.style.top = this.cursor.style.left = `${this.cursorSize / -2
            }px`;
          this.cursor.style.boxShadow =
            "0 0 0 1.25px #FF9100, 0 0 0 2.25px #FF9100";
          this.dot.style.backgroundColor = " white";
        }
    
        click() {
          this.cursor.style.transform += ` scale(0.75)`;
          setTimeout(() => {
            this.cursor.style.transform = this.cursor.style.transform.replace(
              ` scale(0.75)`,
              ""
            );
          }, 35);
        }
    
        remove() {
          this.cursor.remove();
          this.dot.remove();
        }
      }
    
      (() => {
        const cursor = new RingDot();
        if (
          !/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(
            navigator.userAgent
          )
        ) {
          document.onmousemove = function (event) {
            cursor.move(event);
          };
          document.onclick = function () {
            cursor.click();
          };
        } else {
          cursor.remove();
        }
      })();
    </script>
<script type="module">
	import * as PIXI from "https://cdn.skypack.dev/pixi.js@5.x";
import { KawaseBlurFilter } from "https://cdn.skypack.dev/@pixi/filter-kawase-blur@3.2.0";
import SimplexNoise from "https://cdn.skypack.dev/simplex-noise@3.0.0";
import hsl from "https://cdn.skypack.dev/hsl-to-hex";
import debounce from "https://cdn.skypack.dev/debounce";

// return a random number within a range
function random(min, max) {
  return Math.random() * (max - min) + min;
}

// map a number from 1 range to another
function map(n, start1, end1, start2, end2) {
  return ((n - start1) / (end1 - start1)) * (end2 - start2) + start2;
}

// Create a new simplex noise instance
const simplex = new SimplexNoise();

// ColorPalette class
class ColorPalette {
  constructor() {
    this.setColors();
    this.setCustomProperties();
  }

  setColors() {
    // pick a random hue somewhere between 220 and 360
    this.hue = ~~random(220, 360);
    this.complimentaryHue1 = this.hue + 30;
    this.complimentaryHue2 = this.hue + 60;
    // define a fixed saturation and lightness
    this.saturation = 95;
    this.lightness = 50;

    // define a base color
    this.baseColor = hsl(this.hue, this.saturation, this.lightness);
    // define a complimentary color, 30 degress away from the base
    this.complimentaryColor1 = hsl(
      this.complimentaryHue1,
      this.saturation,
      this.lightness
    );
    // define a second complimentary color, 60 degrees away from the base
    this.complimentaryColor2 = hsl(
      this.complimentaryHue2,
      this.saturation,
      this.lightness
    );

    // store the color choices in an array so that a random one can be picked later
    this.colorChoices = [
      this.baseColor,
      this.complimentaryColor1,
      this.complimentaryColor2
    ];
  }

  randomColor() {
    // pick a random color
    return this.colorChoices[~~random(0, this.colorChoices.length)].replace(
      "#",
      "0x"
    );
  }

  setCustomProperties() {
    // set CSS custom properties so that the colors defined here can be used throughout the UI
    document.documentElement.style.setProperty("--hue", this.hue);
    document.documentElement.style.setProperty(
      "--hue-complimentary1",
      this.complimentaryHue1
    );
    document.documentElement.style.setProperty(
      "--hue-complimentary2",
      this.complimentaryHue2
    );
  }
}

// Orb class
class Orb {
  // Pixi takes hex colors as hexidecimal literals (0x rather than a string with '#')
  constructor(fill = 0x000000) {
    // bounds = the area an orb is "allowed" to move within
    this.bounds = this.setBounds();
    // initialise the orb's { x, y } values to a random point within it's bounds
    this.x = random(this.bounds["x"].min, this.bounds["x"].max);
    this.y = random(this.bounds["y"].min, this.bounds["y"].max);

    // how large the orb is vs it's original radius (this will modulate over time)
    this.scale = 1;

    // what color is the orb?
    this.fill = fill;

    // the original radius of the orb, set relative to window height
    this.radius = random(window.innerHeight / 6, window.innerHeight / 3);

    // starting points in "time" for the noise/self similar random values
    this.xOff = random(0, 1000);
    this.yOff = random(0, 1000);
    // how quickly the noise/self similar random values step through time
    this.inc = 0.002;

    // PIXI.Graphics is used to draw 2d primitives (in this case a circle) to the canvas
    this.graphics = new PIXI.Graphics();
    this.graphics.alpha = 0.825;

    // 250ms after the last window resize event, recalculate orb positions.
    window.addEventListener(
      "resize",
      debounce(() => {
        this.bounds = this.setBounds();
      }, 250)
    );
  }

  setBounds() {
    // how far from the { x, y } origin can each orb move
    const maxDist =
      window.innerWidth < 1000 ? window.innerWidth / 3 : window.innerWidth / 5;
    // the { x, y } origin for each orb (the bottom right of the screen)
    const originX = window.innerWidth / 1.25;
    const originY =
      window.innerWidth < 1000
        ? window.innerHeight
        : window.innerHeight / 1.375;

    // allow each orb to move x distance away from it's x / y origin
    return {
      x: {
        min: originX - maxDist,
        max: originX + maxDist
      },
      y: {
        min: originY - maxDist,
        max: originY + maxDist
      }
    };
  }

  update() {
    // self similar "psuedo-random" or noise values at a given point in "time"
    const xNoise = simplex.noise2D(this.xOff, this.xOff);
    const yNoise = simplex.noise2D(this.yOff, this.yOff);
    const scaleNoise = simplex.noise2D(this.xOff, this.yOff);

    // map the xNoise/yNoise values (between -1 and 1) to a point within the orb's bounds
    this.x = map(xNoise, -1, 1, this.bounds["x"].min, this.bounds["x"].max);
    this.y = map(yNoise, -1, 1, this.bounds["y"].min, this.bounds["y"].max);
    // map scaleNoise (between -1 and 1) to a scale value somewhere between half of the orb's original size, and 100% of it's original size
    this.scale = map(scaleNoise, -1, 1, 0.5, 1);

    // step through "time"
    this.xOff += this.inc;
    this.yOff += this.inc;
  }

  render() {
    // update the PIXI.Graphics position and scale values
    this.graphics.x = this.x;
    this.graphics.y = this.y;
    this.graphics.scale.set(this.scale);

    // clear anything currently drawn to graphics
    this.graphics.clear();

    // tell graphics to fill any shapes drawn after this with the orb's fill color
    this.graphics.beginFill(this.fill);
    // draw a circle at { 0, 0 } with it's size set by this.radius
    this.graphics.drawCircle(0, 0, this.radius);
    // let graphics know we won't be filling in any more shapes
    this.graphics.endFill();
  }
}

// Create PixiJS app
const app = new PIXI.Application({
  // render to <canvas class="orb-canvas"></canvas>
  view: document.querySelector(".orb-canvas"),
  // auto adjust size to fit the current window
  resizeTo: window,
  // transparent background, we will be creating a gradient background later using CSS
  transparent: true
});

app.stage.filters = [new KawaseBlurFilter(30, 10, true)];

// Create colour palette
const colorPalette = new ColorPalette();

// Create orbs
const orbs = [];

for (let i = 0; i < 10; i++) {
  const orb = new Orb(colorPalette.randomColor());

  app.stage.addChild(orb.graphics);

  orbs.push(orb);
}

// Animate!
if (!window.matchMedia("(prefers-reduced-motion: reduce)").matches) {
  app.ticker.add(() => {
    orbs.forEach((orb) => {
      orb.update();
      orb.render();
    });
  });
} else {
  orbs.forEach((orb) => {
    orb.update();
    orb.render();
  });
}
document.getElementById('main').style.height=document.getElementsByClassName('orb-canvas')[0].height.toString()+"px"

  window.addEventListener("resize",()=>{
    document.getElementById('main').style.height=document.getElementsByClassName('orb-canvas')[0].height.toString()+"px"
})

/* Set width of all animated text to match container */
let parent = document.querySelectorAll('.animate-text');
for(let i = 0; i < parent.length; i++) {
  parent[i].style.width = parent[i].children[0].clientWidth + "px"; 
};
</script>
  </body>
</html>
